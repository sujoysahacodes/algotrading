# Core dependencies
pandas>=1.5.0
numpy>=1.21.0
scipy>=1.9.0

# Data sources
yfinance>=0.2.0
openbb>=3.0.0
alpaca-trade-api>=3.0.0
ib-insync>=0.9.70

# Technical indicators
ta>=0.10.0
talib-binary>=0.4.25

# Backtesting frameworks
backtrader>=1.9.76
zipline-reloaded>=2.2.0
vectorbt>=0.25.0

# API and networking
requests>=2.28.0
websocket-client>=1.4.0
aiohttp>=3.8.0

# Database
sqlalchemy>=1.4.0
psycopg2-binary>=2.9.0

# Visualization and reporting
matplotlib>=3.5.0
plotly>=5.10.0
streamlit>=1.25.0

# Risk management
pyfolio>=0.9.2

# Configuration and logging
pyyaml>=6.0
python-dotenv>=0.19.0
loguru>=0.6.0

# Scheduling
schedule>=1.2.0

# Testing
pytest>=7.0.0
pytest-asyncio>=0.21.0

# Jupyter for analysis
jupyter>=1.0.0
ipywidgets>=8.0.0
Part I: Generic Strategies Made Proprietary Write code that implements testing on your core strategies, that can be done Python and on historical data (backtesting). Understanding mathematical nuance of indicator, and its backtesting has different purposes, as compared to live-testing which would focus on order slippage, for example. Here, you are not limited to Python, and can use a specialized language + Broker API for Part I as well. There are Backtrader, Zipline, PyAlgoTrade packages but Python does’t have a ready one solution for our Part I purposes. 1. For a core trend-following strategy type, common choices are Exponential Moving Average (EMA) and Average Directional Index (ADX), which is a kind of oscillator. Other approach is a convergence/divergence indicator, Moving Average Convergence/Divergence (MACD). For each strategy, you need to decide on: your own indicator, how it is computed, and what constitutes a trading signal (eg, crossover of 20D EMA with another). 2. Simple but practical trend indicator primarily used in FX is of the following design: • Step 1: resample the prices at regular intervals (eg, 30 seconds) for price level or average; Can use DataFrame.resample; • Step 2: calculate an average price over the longer period (eg, 5-minute intervals). • Step 3: compute the ratio of short-term price (or its average) to long-term average price: near 1 signals ’no trend’ as short-term prices ≈ the long-term prices. Uptrend is signaled by the ratio above 1, and downtrend by less than 1. Give several calibrations.
Full mathematical description of indicators chosen and your calibration: experiment with the ratios over different timeframes, frequency. 3. For a mean-reversion strategy type, • Z ∗ deviation from the price can be used as a simple signal. Or think about distance measures from machine learning. • Formal modeling of mean-reversion with OU process can be invoked expecting the price to mean-revert over short-time. • OPTIONAL To generate a stable P&L from reversion strats, it’s very likely some kind of filtering needs to be applied to the price (see Topic TS). 4. Discussion. Consider the behaviour of the non-stationary price (regime): for example, would the upward trend with more jumps and volatility produce better/worse returns for a mean-reversion? Part II: Broker API and Input data 1. Treat this project as more professional, eg, even for a historical backtesting fetch data from OpenBB/brokerage (vs Yahoo!Finance) and write a couple of routines checking data quality. You are encourage to work with 15-minute and higher-frequency data. 2. The common API choice is REST (Representational State Transfer). • Alpaca, Interactive Brokers Web, and Oanda all have their own versions. In particular, Alpaca REST API is free and includes asynchronous events handling based on WebSocket and Server Side Events (SSE). • REST API is referred to as HTTP API because it utilizes HTTP methods, eg GET (retrieve data), POST (create new data), PUT (update data). Useable for non-timecritical operations such as retrieving historical data, account information, placing orders, and getting order status. 3. The more industrial strength and lower latency API choice is FIX (Financial Information eXchange). A messaging protocol designed for the real-time exchange of securities transactions. It supports submission and cancellation of various order types, trade execution
reports, and market data dissemination – all for high frequency. FIX is used by large institutions, funds, and broker/dealers. 4. Interactive Brokers offer TWS API with connection to their client application and possibility to use C++, C#, Java, Python. A useful comparison at www.interactivebrokers. com/en/index.php?f=5041. Describe order types suitable to your tickers and strategies, and attempt code for order loops and order handling using an API. Set price parameters far from the market to avoid execution. Though, it is absolutely recommended that you do not run any actual live-trading. Part III: Evaluate Risk and Test Thrice An opened market position is exposed to various types of risk. While the market risk can be managed with quant methods like rolling VaR, order-handling risk is more important and reliant on API choices (Part II) as well as dev environment and stack of libraries choices. 1. Containerise and consider docker and crone-style scheduling (think how different parts of your code can be scheduled to run as an independent scripts). Consider implications for running the image of your code data collection, backtest, and trading order loops on a virtual server. 2. Positions Tracking. Code can request account updates (eg, in loop) to provide a secondary confirmation layer. • Code must have a verification of server responses. From the broker side orders may be partially filled and/or returned with an incorrect fill information (eg, ticker not bought when it was actually bought). • Catch the stale websockets and connection issues. 
3. Performance and Risk Reporting. Of less utility to algotrading are Pyfolio-style systematic backtesting, scorecards with concentration in asset vs portfolio, Beta-to-SPY. However, do report on P&L performance, turnover, trading costs, and strategy-specific drawdowns. • One recipe but not mandatory is to present a risk dashboard: run a strategy alike to live for N trading days; save fills and P&L in TimescaleDB (your own database); display drawdown, Sharpe, intraday VaR. You can try Streamlit.
4. Market Data. Introduce simple checks to catch inconsistencies in market data (downloaded for a backtest or received from the broker live). For example, futures price can’t be below spot price, implied quantities can’t be negative
